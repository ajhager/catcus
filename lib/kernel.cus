JS: clear
	"catcus = [];" ;

JS: exit
	"process.exit();" ;

JS: add
	"catcus.push(catcus.pop() + catcus.pop());" ;

JS: inc
	"catcus.push(catcus.pop() + 1);" ;

JS: sub
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() - catcus1);" ;

JS: dec
	"catcus.push(catcus.pop() - 1);" ;

JS: mul
	"catcus.push(catcus.pop() * catcus.pop());" ;

JS: div
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() / catcus1);" ;

JS: mod
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() % catcus1);" ;

JS: print
	"console.log(catcus.pop());" ;

JS: eq
	"catcus.push(catcus.pop() === catcus.pop());" ;

JS: neq
	"catcus.push(catcus.pop() !== catcus.pop());" ;

JS: lt
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() < catcus1);" ;

JS: lte
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() <= catcus1);" ;

JS: gt
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() > catcus1);" ;

JS: gte
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() >= catcus1);" ;

JS: and
	"catcus.push(catcus.pop() && catcus.pop());" ;

JS: or
	"catcus.push(catcus.pop() || catcus.pop());" ;

JS: not
	"catcus.push(!catcus.pop());" ;

JS: AND
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() & catcus1);" ;

JS: OR
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() | catcus1);" ;

JS: NOT
	"catcus.push(~catcus.pop());" ;

JS: XOR
	"catcus.push(^catcus.pop());" ;

JS: LSHIFT
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() << catcus1);" ;

JS: RSHIFT
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus.pop() >> catcus1);" ;

JS: dup
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus1);"
	"catcus.push(catcus1);" ;

JS: dup2
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);" ;

JS: dup3
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"var catcus3 = catcus.pop();"
	"catcus.push(catcus3);"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);"
	"catcus.push(catcus3);"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);" ;

JS: dup4
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"var catcus3 = catcus.pop();"
	"var catcus4 = catcus.pop();"
	"catcus.push(catcus4);"
	"catcus.push(catcus3);"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);"
	"catcus.push(catcus4);"
	"catcus.push(catcus3);"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);" ;

JS: drop
	"catcus.pop();" ;

JS: drop2
	"catcus.pop();" "catcus.pop();" ;

JS: drop3
	"catcus.pop();" "catcus.pop();" "catcus.pop();" ;

JS: drop4
	"catcus.pop();" "catcus.pop();" "catcus.pop();" "catcus.pop();" ;

JS: swap
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus.push(catcus1);"
	"catcus.push(catcus2);" ;

JS: nip
	"var catcus1 = catcus.pop();"
	"catcus.pop();"
	"catcus.push(catcus1);" ;

JS: nip2
	"var catcus1 = catcus.pop();"
	"catcus.pop();"
	"catcus.pop();"
	"catcus.push(catcus1);" ;
	
JS: over
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);"
	"catcus.push(catcus2);" ;

JS: over2
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"var catcus3 = catcus.pop();"
	"catcus.push(catcus3);"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);"
	"catcus.push(catcus3);"
	"catcus.push(catcus2);" ;

JS: pick
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"var catcus3 = catcus.pop();"
	"catcus.push(catcus3);"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);"
	"catcus.push(catcus3);" ;

JS: rot
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"var catcus3 = catcus.pop();"
	"catcus.push(catcus2);"
	"catcus.push(catcus1);"
	"catcus.push(catcus3);" ;

JS: call
	"catcus.pop()();" ;

JS: dip
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus1();"
	"catcus.push(catcus2);" ;

FUNC: dip2
	swap { dip } dip ;

JS: curry
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus.push(function() {"
	"catcus.push(catcus2);"
	"catcus1();"
	"});" ;

JS: compose
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus.push(function() {"
	"catcus2();"
	"catcus1();"
	"});" ;

JS: ifelse
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus.pop() ? catcus2() : catcus1();" ;

JS: loop
	"var catcus1 = catcus.pop();"
	"while (true) {"
	"catcus1();"
	"if (!catcus.pop()) break;"
	"}" ;

JS: array
	"catcus.push([]);" ;

JS: array1
	"catcus.push([catcus.pop()]);" ;

JS: array2
	"var catcus1 = catcus.pop();"
	"catcus.push([catcus.pop(), catcus1]);" ;

JS: array3
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus.push([catcus.pop(), catcus2, catcus1]);" ;

JS: array4
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"var catcus3 = catcus.pop();"
	"catcus.push([catcus.pop(), catcus3, catcus2, catcus1]);" ;

JS: push
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus2.push(catcus1);"
	"catcus.push(catcus2);" ;

JS: map
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus.push(catcus2.map(function(v) {"
	"catcus.push(v);"
	"catcus1();"
	"return catcus.pop();"
	"}));" ;

JS: concat
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus.push(catcus2.concat(catcus1));" ;

JS: length
	"catcus.push(catcus.pop().length);" ;

JS: get
	"var catcus1 = catcus.pop();"
	"catcus.push(catcus1[catcus.pop()]);" ;

JS: set
	"var catcus1 = catcus.pop();"
	"var catcus2 = catcus.pop();"
	"catcus1[catcus2] = catcus.pop();" ;

// Call a function with a value on the stack,
// restoring the value when the function returns.
FUNC: keep
	over { call } dip ;

// Apply two functions to one value.
FUNC: _bi
	{ keep } dip call ;

// Apply two functions to two values, respectively.
FUNC: bi
	{ dip } dip call ;

// Apply one function to two values in turn.
FUNC: bi_
	dup bi ;

// Apply three functions to one value.
FUNC: _tri
	{ { keep } dip keep } dip call ;

// Apply three functions to three values, respectively.
FUNC: tri
	{ { dip2 } dip dip } dip call ;

// Apply one function to three values in turn.
FUNC: tri_
	dup dup tri ;

// Call a function if the value is true.
FUNC: when
	swap { call } { drop } ifelse ;
